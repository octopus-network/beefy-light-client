use beefy_merkle_tree::{Hash, Keccak256};
use codec::Encode;

#[derive(Debug, Default, Encode)]
pub struct Header {
	/// The parent hash.
	pub parent_hash: Hash,
	/// The block number.
	pub number: u32,
	/// The state trie merkle root
	pub state_root: Hash,
	/// The merkle root of the extrinsics.
	pub extrinsics_root: Hash,
	/// A chain-specific digest of data useful for light clients or referencing auxiliary data.
	pub digest: Digest,
}

impl Header {
	pub fn hash(&self) -> Hash {
		Keccak256::hash(&self.encode())
	}

	pub fn get_other(&self) -> Option<Vec<u8>> {
		self.digest.logs.iter().find_map(|item| match item {
			DigestItem::Other(data) => Some(data.clone()),
			_ => None,
		})
	}
}

#[derive(Debug, Default, Encode)]
pub struct Digest {
	/// A list of logs in the digest.
	pub logs: Vec<DigestItem>,
}

/// Consensus engine unique ID.
pub type ConsensusEngineId = [u8; 4];

#[derive(Debug, Encode)]
pub enum DigestItem {
	/// System digest item that contains the root of changes trie at given
	/// block. It is created for every block iff runtime supports changes
	/// trie creation.
	ChangesTrieRoot(Hash),

	/// A pre-runtime digest.
	///
	/// These are messages from the consensus engine to the runtime, although
	/// the consensus engine can (and should) read them itself to avoid
	/// code and state duplication. It is erroneous for a runtime to produce
	/// these, but this is not (yet) checked.
	///
	/// NOTE: the runtime is not allowed to panic or fail in an `on_initialize`
	/// call if an expected `PreRuntime` digest is not present. It is the
	/// responsibility of a external block verifier to check this. Runtime API calls
	/// will initialize the block without pre-runtime digests, so initialization
	/// cannot fail when they are missing.
	PreRuntime(ConsensusEngineId, Vec<u8>),

	/// A message from the runtime to the consensus engine. This should *never*
	/// be generated by the native code of any consensus engine, but this is not
	/// checked (yet).
	Consensus(ConsensusEngineId, Vec<u8>),

	/// Put a Seal on it. This is only used by native code, and is never seen
	/// by runtimes.
	Seal(ConsensusEngineId, Vec<u8>),

	/// Digest item that contains signal from changes tries manager to the
	/// native code.
	ChangesTrieSignal(ChangesTrieSignal),

	/// Some other thing. Unsupported and experimental.
	Other(Vec<u8>),

	/// An indication for the light clients that the runtime execution
	/// environment is updated.
	///
	/// Currently this is triggered when:
	/// 1. Runtime code blob is changed or
	/// 2. `heap_pages` value is changed.
	RuntimeEnvironmentUpdated,
}

#[derive(Debug, Encode)]
pub enum ChangesTrieSignal {
	/// New changes trie configuration is enacted, starting from **next block**.
	///
	/// The block that emits this signal will contain changes trie (CT) that covers
	/// blocks range [BEGIN; current block], where BEGIN is (order matters):
	/// - LAST_TOP_LEVEL_DIGEST_BLOCK+1 if top level digest CT has ever been created using current
	///   configuration AND the last top level digest CT has been created at block
	///   LAST_TOP_LEVEL_DIGEST_BLOCK;
	/// - LAST_CONFIGURATION_CHANGE_BLOCK+1 if there has been CT configuration change before and
	///   the last configuration change happened at block LAST_CONFIGURATION_CHANGE_BLOCK;
	/// - 1 otherwise.
	NewConfiguration(Option<ChangesTrieConfiguration>),
}

#[derive(Debug, Default, Encode)]
pub struct ChangesTrieConfiguration {
	/// Interval (in blocks) at which level1-digests are created. Digests are not
	/// created when this is less or equal to 1.
	pub digest_interval: u32,
	/// Maximal number of digest levels in hierarchy. 0 means that digests are not
	/// created at all (even level1 digests). 1 means only level1-digests are created.
	/// 2 means that every digest_interval^2 there will be a level2-digest, and so on.
	/// Please ensure that maximum digest interval (i.e. digest_interval^digest_levels)
	/// is within `u32` limits. Otherwise you'll never see digests covering such intervals
	/// && maximal digests interval will be truncated to the last interval that fits
	/// `u32` limits.
	pub digest_levels: u32,
}
